# project_extension/extension/configs.py
"""
This module defines the experimental configuration space for the project.

It provides a set of immutable data structures that formalize all tunable
components of the training and evaluation pipeline, including actuator
fault models, goal specifications, safety constraints, reward shaping,
domain randomization parameters, and environment identifiers.

The configuration is organized around two main experimental axes:

1. Proposal 1 - Resilience to actuator degradation
   - FaultSpec defines hard actuator faults applied at evaluation time,
     including fault strength, affected actuators, and onset timing.
   - A systematic stress-test grid is generated by combining multiple
     actuator indices, degradation levels, and fault start steps.

2. Proposal 2 - Goal-conditioned and safety-aware locomotion
   - GoalSpec, RewardSpec, and SafetySpec define the goal distribution,
     shaped reward structure, and safety constraints.
   - FrictionDRSpec enables domain randomization of ground friction to
     improve robustness to environmental variations.

The ExperimentConfig dataclass aggregates all relevant parameters into a
single immutable configuration object, ensuring reproducibility and
preventing accidental drift across training and evaluation phases.

Finally, this module defines the global experiment registry (EXPERIMENTS),
random seeds, and fault grids used throughout the project to enable
systematic benchmarking, controlled ablations, and fair comparison between
baseline and resilience-enhanced agents.
"""
from __future__ import annotations

from dataclasses import dataclass
from typing import List, Optional, Tuple, Literal

Algo = Literal["SAC"]

# proposal 1: Fault Spec
@dataclass(frozen=True)
class FaultSpec:
    """
    strength:
        Multiplicative scaling on selected action components.
        strength = 0.7 -> -30% torque (keeps 70%)
        strength = 0.5 -> -50% torque (keeps 50%)
        strength = 0.3 -> -70% torque (keeps 30%)
    """
    strength: float = 0.5
    actuator_indices: Tuple[int, ...] = (1,)
    start_step: Optional[int] = None
    tag: str = "default"

# proposal 2: Goal + Safety + Reward + Friction DR
@dataclass(frozen=True)
class GoalSpec:
    x: float
    y: float = 0.0


@dataclass(frozen=True)
class SafetySpec:
    max_torso_pitch_rad: float = 0.7
    max_vertical_speed: float = 6.0
    terminate_on_violation: bool = False  # allow recovery, don't hard-stop
    penalty_torso: float = 5.0
    penalty_vertical_speed: float = 1.0


@dataclass(frozen=True)
class RewardSpec:
    """
    Shaped goal reward:
      + alive_bonus
      + w_progress * (prev_dist - dist)
      - w_distance * dist
      - w_action_l2 * ||a||^2
      - w_action_change_l2 * ||a - a_prev||^2
      + success_bonus on success
    """
    # MOD: make progress signal stronger and distance penalty less punishing
    w_progress: float = 3.0
    w_distance: float = 0.08
    w_action_l2: float = 0.01
    w_action_change_l2: float = 0.005
    # MOD: encourage staying alive / upright a bit more
    alive_bonus: float = 0.5

    # bonus when reaching the goal
    success_bonus: float = 100.0


@dataclass(frozen=True)
class FrictionDRSpec:
    range: float = 0.0
    geom_names: Tuple[str, ...] = ("floor",)

# Experiment config
@dataclass(frozen=True)
class ExperimentConfig:
    name: str
    algo: Algo = "SAC"

    # train/eval
    total_timesteps: int = 500_000
    n_eval_episodes: int = 100
    source_env_id: str = "CustomHopper-source-v0"
    target_env_id: str = "CustomHopper-target-v0"

    # P1 resilience
    actuator_dr_range: float = 0.0
    safety_lambda_action_l2: float = 0.0
    fault: Optional[FaultSpec] = None

    # P2 knobs (goal + safety + friction)
    goals: Optional[Tuple[GoalSpec, ...]] = None

    # P2 goal reachable but not trivial
    goal_x_min: float = 1.5
    goal_x_max: float = 3.0
    goal_y: float = 0.0
    goal_tolerance: float = 0.6

    # harder goal under faults
    fault_goal_x_min: float = 6.0
    fault_goal_x_max: float = 10.0
    fault_goal_tolerance: float = 0.45

    max_episode_steps: Optional[int] = None

    reward: RewardSpec = RewardSpec()
    safety: SafetySpec = SafetySpec()
    friction_dr: FrictionDRSpec = FrictionDRSpec()

# P1 Stress-test grid (eval_fault / eval_fault_goal)
FAULT_ACTUATORS_TO_TEST: List[Tuple[int, ...]] = [(0,), (1,), (2,)]
FAULT_STRENGTH_LEVELS: List[float] = [0.7, 0.5, 0.3]
FAULT_START_STEPS: List[Optional[int]] = [0, 50, 150]

EVAL_FAULT_SPECS: List[FaultSpec] = []
for idxs in FAULT_ACTUATORS_TO_TEST:
    for s in FAULT_STRENGTH_LEVELS:
        for t0 in FAULT_START_STEPS:
            tag = f"a{idxs[0]}_s{s}_t{t0}"
            EVAL_FAULT_SPECS.append(FaultSpec(strength=s, actuator_indices=idxs, start_step=t0, tag=tag))

# Seeds + EXPERIMENTS
SEEDS: List[int] = [0, 1, 2]

FRICTION_RANGE = 0.20
RES_DR_ON = 0.30

# bootstrap reward aligned with RewardSpec above
BOOT_REWARD = RewardSpec(
    alive_bonus=0.5,
    w_progress=3.0,
    w_distance=0.2,
    w_action_l2=0.003,          
    w_action_change_l2=0.005,   
    success_bonus=100.0,
)


EXPERIMENTS: List[ExperimentConfig] = [
    # Baseline: NO actuator DR
    ExperimentConfig(
        name="MSR_fast_noRes",
        actuator_dr_range=0.0,
        friction_dr=FrictionDRSpec(range=FRICTION_RANGE, geom_names=("floor",)),
        safety=SafetySpec(
            max_torso_pitch_rad=0.7,
            max_vertical_speed=6.0,
            terminate_on_violation=False,
            penalty_torso=5.0,
            penalty_vertical_speed=1.0,
        ),
        reward=BOOT_REWARD,
    ),
    # Resilient: actuator DR ON
    ExperimentConfig(
        name="MSR_fast_resDR",
        actuator_dr_range=RES_DR_ON,
        friction_dr=FrictionDRSpec(range=FRICTION_RANGE, geom_names=("floor",)),
        safety=SafetySpec(
            max_torso_pitch_rad=0.7,
            max_vertical_speed=6.0,
            terminate_on_violation=False,
            penalty_torso=5.0,
            penalty_vertical_speed=1.0,
        ),
        reward=BOOT_REWARD,
    ),
]